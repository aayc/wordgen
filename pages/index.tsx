import type { NextPage } from "next";
import Head from "next/head";
import Image from "next/image";
import { Checkbox } from "primereact/checkbox";
import { Slider } from "primereact/slider";
import { InputNumber } from "primereact/inputnumber";
import { InputText } from "primereact/inputtext";
import { Button } from "primereact/button";
import styles from "../styles/Home.module.css";
import { useEffect, useState } from "react";
import { GeneratorOptions, SentimentClass, WordResult } from "../utils/types";
import WordResultTag from "../components/WordResultTag";
import { MultiSelect } from "primereact/multiselect";

const Home: NextPage = () => {
  const [words, setWords] = useState<WordResult[] | null>([]);
  const [loading, setLoading] = useState<boolean>(false);
  const [numWords, setNumWords] = useState<number>(1);
  const [minLength, setMinLength] = useState(0);
  const [maxLength, setMaxLength] = useState(1000);
  const [startsWith, setStartsWith] = useState("");
  const [partsOfSpeech, setPartsOfSpeech] = useState<string[]>([]);
  const [endsWith, setEndsWith] = useState("");
  const [sentimentBounds, setSentimentBounds] = useState<any>([0, 100]);
  const [freqBounds, setFreqBounds] = useState<any>([0, 100]);
  const [similarTo, setSimilarTo] = useState<string>("");

  const parseSentiment = (sentiment: number): [number, SentimentClass] => {
    const s = (sentiment - 50) / 50;
    if (s < -0.25) {
      return [s, "negative"];
    } else if (s > 0.25) {
      return [s, "positive"];
    } else {
      return [s, "neutral"];
    }
  };

  const downloadWordsAsCsv = async () => {
    // Take words array and download as csv
    if (words) {
      const header = [
        "word",
        "freq precentile",
        "sentiment",
        "parts of speech",
      ].join(",");
      const csv = words
        .map((word: WordResult) => {
          return `${word.word},${word.percentile},${
            word.sentiment
          },${word.partsOfSpeech.join(":")}`;
        })
        .join("\n");
      const blob = new Blob([header + "\n" + csv], { type: "text/csv" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.href = url;
      link.download = "words.csv";
      link.click();
    }
  };

  const requestWords = (): void => {
    setLoading(true);
    if (numWords > 1000) {
      alert("Please generate no more than 1000 words at a time");
      setLoading(false);
      return;
    }

    const body: GeneratorOptions = {
      numWords,
      minLength,
      maxLength,
      startsWith,
      endsWith,
      sentimentBounds: [
        parseSentiment(sentimentBounds[0])[0],
        parseSentiment(sentimentBounds[1])[0],
      ],
      freqBounds,
      partsOfSpeech:
        partsOfSpeech.length > 0
          ? partsOfSpeech
          : ["Noun", "Verb", "Adjective", "Adverb"],
      similarTo: similarTo.split(",")
    };

    fetch("/api/words", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.words.length == 1 && !("word" in data.words[0])) {
          setWords(null);
        } else {
          setWords(data.words);
        }
        setLoading(false);
      });
  };

  return (
    <div>
      <Head>
        <title>Aaron&rsquo;s Word Generator</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <div className="my-8 flex justify-center px-4">
        <div className="max-w-2xl">
          <h1 className="text-center">Aaron&rsquo;s Word Generator</h1>
          <p className="mt-8"># of words to generate:</p>
          <InputNumber
            value={numWords}
            onChange={(e) => setNumWords(e.value!)}
          />
          <p className="mt-8">Minimum # of letters:</p>
          <InputNumber
            value={minLength}
            onChange={(e) => setMinLength(e.value!)}
          />
          <p className="mt-4">Maximum # of letters:</p>
          <InputNumber
            value={maxLength}
            onChange={(e) => setMaxLength(e.value!)}
          />
          <p className="mt-4">Starts with:</p>
          <InputText
            value={startsWith}
            onChange={(e) => setStartsWith(e.target.value)}
          />
          <p className="mt-4">Ends with:</p>
          <InputText
            value={endsWith}
            onChange={(e) => setEndsWith(e.target.value)}
          />
          <p className="mt-4">Parts of speech:</p>
          <MultiSelect
            value={partsOfSpeech}
            options={["Noun", "Verb", "Adjective", "Adverb"].map((s) => ({
              label: s,
              value: s,
            }))}
            onChange={(e: any) => {
              console.log(e.value);
              setPartsOfSpeech(e.value);
            }}
            placeholder="Select Parts of Speech"
          />

          <p className="mt-4">
            Sentiment: {parseSentiment(sentimentBounds[0])[1]} (
            {parseSentiment(sentimentBounds[0])[0]}) to{" "}
            {parseSentiment(sentimentBounds[1])[1]} (
            {parseSentiment(sentimentBounds[1])[0]})
          </p>
          <Slider
            className="mt-4"
            value={sentimentBounds}
            onChange={(e) => setSentimentBounds(e.value)}
            range
          />

          <p className="mt-8">
            Word frequency: {freqBounds[0]}th percentile (less common) to{" "}
            {freqBounds[1]}th percentile (more common):
          </p>
          <Slider
            className="mt-4"
            value={freqBounds}
            onChange={(e) => setFreqBounds(e.value)}
            range
          />
          <p className="mt-4">Similar to (words separated by comma):</p>
          <InputText
            value={similarTo}
            onChange={(e) => setSimilarTo(e.target.value)}
          />
          <div className="mt-4 flex justify-center">
            <Button
              label={
                loading
                  ? "Generating..."
                  : !words || words.length == 0
                  ? "Generate"
                  : "Generate again"
              }
              className=""
              disabled={loading}
              onClick={requestWords}
            />
          </div>

          {words ? (
            words.length > 0 && (
              <div className="mt-8">
                <hr></hr>
                <div className="flex justify-between mb-8">
                  <h1 className="text-center mt-1">Results:</h1>
                  <Button
                    className="p-button-sm"
                    label="Download words as CSV"
                    icon="pi pi-download"
                    onClick={(e) => downloadWordsAsCsv()}
                  ></Button>
                </div>
                <div className="flex flex-wrap">
                  {words.map((word) => (
                    <WordResultTag key={JSON.stringify(word)} word={word} />
                  ))}
                </div>
              </div>
            )
          ) : (
            <div className="mt-8">
              <h1 className="text-center">Unable to generate words</h1>
            </div>
          )}
        </div>
      </div>

      <div className="bg-black text-white text-center py-8">
        Want me to add a feature? Submit your idea{" "}
        <a
          className="font-semibold underline transition duration-200 ease-in-out hover:text-gray-300"
          href="https://forms.gle/GWoCxk1bsHs3NeVQ9"
        >
          here.
        </a>
      </div>
    </div>
  );
};

export default Home;
